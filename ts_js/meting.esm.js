import {
	URLSearchParams as t
} from "url";
import e from "crypto";
class r {
	constructor(t) {
		this.meting = t, this.name = "base"
	}
	getHeaders() {
		return {}
	}
	search(t, e = {}) {
		throw new Error(`${this.name} provider must implement search method`)
	}
	song(t) {
		throw new Error(`${this.name} provider must implement song method`)
	}
	album(t) {
		throw new Error(`${this.name} provider must implement album method`)
	}
	artist(t, e = 50) {
		throw new Error(`${this.name} provider must implement artist method`)
	}
	playlist(t) {
		throw new Error(`${this.name} provider must implement playlist method`)
	}
	url(t, e = 320) {
		throw new Error(`${this.name} provider must implement url method`)
	}
	lyric(t) {
		throw new Error(`${this.name} provider must implement lyric method`)
	}
	async pic(t, e = 300) {
		throw new Error(`${this.name} provider must implement pic method`)
	}
	format(t) {
		throw new Error(`${this.name} provider must implement format method`)
	}
	urlDecode(t) {
		return t
	}
	lyricDecode(t) {
		return t
	}
	async executeRequest(t, e) {
		if (t.encode && (t = await this.handleEncode(t)), "GET" === t.method && t.body) {
			const e = new URLSearchParams(t.body);
			t.url += "?" + e.toString(), t.body = null
		}
		if (await e._curl(t.url, t.body), !e.isFormat) return e.raw;
		let r = e.raw;
		return t.decode && (r = await this.handleDecode(t.decode, r)), t.format && (r = this.cleanData(r, t.format, e)), r
	}
	async handleEncode(t) {
		return t
	}
	async handleDecode(t, e) {
		return t.includes("url") ? this.urlDecode(e) : t.includes("lyric") ? this.lyricDecode(e) : e
	}
	cleanData(t, e, r) {
		let i;
		try {
			i = JSON.parse(t)
		} catch (t) {
			return JSON.stringify([])
		}
		if (e && (i = this.pickupData(i, e)), Array.isArray(i) || "object" != typeof i || null === i || (i = [i]), !Array.isArray(i)) return JSON.stringify([]);
		if ("function" == typeof this.format) {
			const t = i.map(t => this.format(t));
			return JSON.stringify(t)
		}
		return JSON.stringify(i)
	}
	pickupData(t, e) {
		const r = e.split(".");
		let i = t;
		for (const t of r) {
			if (!i || "object" != typeof i || !(t in i)) return {};
			i = i[t]
		}
		return i
	}
}
Buffer.from("0102030405060708");
class i extends r {
	constructor(t) {
		super(t), this.name = "netease"
	}
	getHeaders() {
		const t = Date.now().toString();
		return {
			Referer: "music.163.com",
			Cookie: `osver=android; appver=8.7.01; os=android; deviceId=${this._generateDeviceId()}; channel=netease; requestId=${t}_${Math.floor(1e3*Math.random()).toString().padStart(4,"0")}; __remember_me=true`,
			"User-Agent": "Mozilla/5.0 (Linux; Android 11; M2007J3SC Build/RKQ1.200826.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/77.0.3865.120 MQQBrowser/6.2 TBS/045714 Mobile Safari/537.36 NeteaseMusic/8.7.01",
			Accept: "*/*",
			"Accept-Language": "zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7",
			Connection: "keep-alive",
			"Content-Type": "application/x-www-form-urlencoded"
		}
	}
	search(t, e = {}) {
		return {
			method: "POST",
			url: "http://music.163.com/api/cloudsearch/pc",
			body: {
				s: t,
				type: e.type || 1,
				limit: e.limit || 30,
				total: "true",
				offset: e.page && e.limit ? (e.page - 1) * e.limit : 0
			},
			encode: "netease_eapi",
			format: "result.songs"
		}
	}
	song(t) {
		return {
			method: "POST",
			url: "http://music.163.com/api/v3/song/detail/",
			body: {
				c: `[{"id":${t},"v":0}]`
			},
			encode: "netease_eapi",
			format: "songs"
		}
	}
	album(t) {
		return {
			method: "POST",
			url: `http://music.163.com/api/v1/album/${t}`,
			body: {
				total: "true",
				offset: "0",
				id: t,
				limit: "1000",
				ext: "true",
				private_cloud: "true"
			},
			encode: "netease_eapi",
			format: "songs"
		}
	}
	artist(t, e = 50) {
		return {
			method: "POST",
			url: `http://music.163.com/api/v1/artist/${t}`,
			body: {
				ext: "true",
				private_cloud: "true",
				top: e,
				id: t
			},
			encode: "netease_eapi",
			format: "hotSongs"
		}
	}
	playlist(t) {
		return {
			method: "POST",
			url: "http://music.163.com/api/v6/playlist/detail",
			body: {
				s: "0",
				id: t,
				n: "1000",
				t: "0"
			},
			encode: "netease_eapi",
			format: "playlist.tracks"
		}
	}
	url(t, e = 320) {
		return {
			method: "POST",
			url: "http://music.163.com/api/song/enhance/player/url",
			body: {
				ids: [t],
				br: 1e3 * e
			},
			encode: "netease_eapi",
			decode: "netease_url"
		}
	}
	lyric(t) {
		return {
			method: "POST",
			url: "http://music.163.com/api/song/lyric",
			body: {
				id: t,
				os: "linux",
				lv: -1,
				kv: -1,
				tv: -1
			},
			encode: "netease_eapi",
			decode: "netease_lyric"
		}
	}
	async pic(t, e = 300) {
		const r = `https://p3.music.126.net/${this._encryptId(t)}/${t}.jpg?param=${e}y${e}`;
		return JSON.stringify({
			url: r
		})
	}
	format(t) {
		const e = {
			id: t.id,
			name: t.name,
			artist: [],
			album: t.al.name,
			pic_id: t.al.pic_str || t.al.pic,
			url_id: t.id,
			lyric_id: t.id,
			source: "netease"
		};
		if (t.al.picUrl) {
			const r = t.al.picUrl.match(/\/(\d+)\./);
			r && (e.pic_id = r[1])
		}
		return t.ar.forEach(t => {
			e.artist.push(t.name)
		}), e
	}
	async handleEncode(t) {
		return "netease_eapi" === t.encode ? this.eapiEncrypt(t) : t
	}
	async eapiEncrypt(t) {
		const r = JSON.stringify(t.body),
			i = t.url.replace(/https?:\/\/[^\/]+/, ""),
			a = `nobody${i}use${r}md5forencrypt`,
			o = `${i}-36cd479b6b5-${r}-36cd479b6b5-${e.createHash("md5").update(a).digest("hex")}`,
			s = e.createCipheriv("aes-128-ecb", Buffer.from("e82ckenh8dichen8", "utf8"), null);
		s.setAutoPadding(!0);
		let n = s.update(o, "utf8", "hex");
		return n += s.final("hex"), t.url = t.url.replace("/api/", "/eapi/"), t.body = {
			params: n.toUpperCase()
		}, t
	}
	urlDecode(t) {
		const e = JSON.parse(t);
		let r;
		return e.data[0].uf && e.data[0].uf.url && (e.data[0].url = e.data[0].uf.url), r = e.data[0].url ? {
			url: e.data[0].url,
			size: e.data[0].size,
			br: e.data[0].br / 1e3
		} : {
			url: "",
			size: 0,
			br: -1
		}, JSON.stringify(r)
	}
	lyricDecode(t) {
		const e = JSON.parse(t),
			r = {
				lyric: e.lrc && e.lrc.lyric ? e.lrc.lyric : "",
				tlyric: e.tlyric && e.tlyric.lyric ? e.tlyric.lyric : ""
			};
		return JSON.stringify(r)
	}
	_generateRandomIP() {
		const t = 1884815360,
			e = Math.floor(74752 * Math.random()) + t;
		return [e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e].join(".")
	}
	_getRandomHex(t) {
		return e.randomBytes(Math.ceil(t / 2)).toString("hex").slice(0, t)
	}
	_generateDeviceId() {
		return e.randomBytes(16).toString("hex").toUpperCase()
	}
	_encryptId(t) {
		const r = "3go8&$8*3*3h0k(2)2".split(""),
			i = String(t).split("");
		for (let t = 0; t < i.length; t++) i[t] = String.fromCharCode(i[t].charCodeAt(0) ^ r[t % r.length].charCodeAt(0));
		return e.createHash("md5").update(i.join(""), "binary").digest("base64").replace(/\//g, "_").replace(/\+/g, "-")
	}
	_bchexdec(t) {
		return BigInt("0x" + t)
	}
	_str2hex(t) {
		return Buffer.from(t, "utf8").toString("hex")
	}
	_powMod(t, e, r) {
		if (1n === r) return 0n;
		let i = 1n;
		for (t %= r; e > 0n;) e % 2n == 1n && (i = i * t % r), e >>= 1n, t = t * t % r;
		return i
	}
}
class a extends r {
	constructor(t) {
		super(t), this.name = "tencent"
	}
	getHeaders() {
		return {
			Referer: "http://y.qq.com",
			Cookie: "pgv_pvi=22038528; pgv_si=s3156287488; pgv_pvid=5535248600; yplayer_open=1; ts_last=y.qq.com/portal/player.html; ts_uid=4847550686; yq_index=0; qqmusic_fromtag=66; player_exist=1",
			"User-Agent": "QQ%E9%9F%B3%E4%B9%90/54409 CFNetwork/901.1 Darwin/17.6.0 (x86_64)",
			Accept: "*/*",
			"Accept-Language": "zh-CN,zh;q=0.8,gl;q=0.6,zh-TW;q=0.4",
			Connection: "keep-alive",
			"Content-Type": "application/x-www-form-urlencoded"
		}
	}
	search(t, e = {}) {
		return {
			method: "GET",
			url: "https://c.y.qq.com/soso/fcgi-bin/client_search_cp",
			body: {
				format: "json",
				p: e.page || 1,
				n: e.limit || 30,
				w: t,
				aggr: 1,
				lossless: 1,
				cr: 1,
				new_json: 1
			},
			format: "data.song.list"
		}
	}
	song(t) {
		return {
			method: "GET",
			url: "https://c.y.qq.com/v8/fcg-bin/fcg_play_single_song.fcg",
			body: {
				songmid: t,
				platform: "yqq",
				format: "json"
			},
			format: "data"
		}
	}
	album(t) {
		return {
			method: "GET",
			url: "https://c.y.qq.com/v8/fcg-bin/fcg_v8_album_detail_cp.fcg",
			body: {
				albummid: t,
				platform: "mac",
				format: "json",
				newsong: 1
			},
			format: "data.getSongInfo"
		}
	}
	artist(t, e = 50) {
		return {
			method: "GET",
			url: "https://c.y.qq.com/v8/fcg-bin/fcg_v8_singer_track_cp.fcg",
			body: {
				singermid: t,
				begin: 0,
				num: e,
				order: "listen",
				platform: "mac",
				newsong: 1
			},
			format: "data.list"
		}
	}
	playlist(t) {
		return {
			method: "GET",
			url: "https://c.y.qq.com/v8/fcg-bin/fcg_v8_playlist_cp.fcg",
			body: {
				id: t,
				format: "json",
				newsong: 1,
				platform: "jqspaframe.json"
			},
			format: "data.cdlist.0.songlist"
		}
	}
	url(t, e = 320) {
		return {
			method: "GET",
			url: "https://c.y.qq.com/v8/fcg-bin/fcg_play_single_song.fcg",
			body: {
				songmid: t,
				platform: "yqq",
				format: "json"
			},
			decode: "tencent_url"
		}
	}
	lyric(t) {
		return {
			method: "GET",
			url: "https://c.y.qq.com/lyric/fcgi-bin/fcg_query_lyric_new.fcg",
			body: {
				songmid: t,
				g_tk: "5381"
			},
			decode: "tencent_lyric"
		}
	}
	async pic(t, e = 300) {
		const r = `https://y.gtimg.cn/music/photo_new/T002R${e}x${e}M000${t}.jpg?max_age=2592000`;
		return JSON.stringify({
			url: r
		})
	}
	format(t) {
		t.musicData && (t = t.musicData);
		const e = {
			id: t.mid,
			name: t.name,
			artist: [],
			album: t.album.title.trim(),
			pic_id: t.album.mid,
			url_id: t.mid,
			lyric_id: t.mid,
			source: "tencent"
		};
		return t.singer.forEach(t => {
			e.artist.push(t.name)
		}), e
	}
	async handleDecode(t, e) {
		return "tencent_url" === t ? this.urlDecode(e) : "tencent_lyric" === t ? this.lyricDecode(e) : e
	}
	async urlDecode(t) {
		const e = JSON.parse(t),
			r = Math.floor(1e10 * Math.random()),
			i = [
				["size_flac", 999, "F000", "flac"],
				["size_320mp3", 320, "M800", "mp3"],
				["size_192aac", 192, "C600", "m4a"],
				["size_128mp3", 128, "M500", "mp3"],
				["size_96aac", 96, "C400", "m4a"],
				["size_48aac", 48, "C200", "m4a"],
				["size_24aac", 24, "C100", "m4a"]
			];
		let a = "0";
		const o = this.meting.header.Cookie && this.meting.header.Cookie.match(/uin=(\d+)/);
		o && (a = o[1]);
		const s = {
			req_0: {
				module: "vkey.GetVkeyServer",
				method: "CgiGetVkey",
				param: {
					guid: String(r),
					songmid: [],
					filename: [],
					songtype: [],
					uin: a,
					loginflag: 1,
					platform: "20"
				}
			}
		};
		i.forEach(([t, r, i, a]) => {
			s.req_0.param.songmid.push(e.data[0].mid), s.req_0.param.filename.push(`${i}${e.data[0].file.media_mid}.${a}`), s.req_0.param.songtype.push(e.data[0].type)
		});
		const n = {
				method: "GET",
				url: "https://u.y.qq.com/cgi-bin/musicu.fcg",
				body: {
					format: "json",
					platform: "yqq.json",
					needNewCode: 0,
					data: JSON.stringify(s)
				}
			},
			c = JSON.parse(await this.meting._exec(n)),
			d = c.req_0.data.midurlinfo;
		let l;
		for (let t = 0; t < i.length; t++) {
			const [r, a, o, s] = i[t];
			if (e.data[0].file[r] && a <= this.meting.temp.br && d[t].vkey) {
				l = {
					url: c.req_0.data.sip[0] + d[t].purl,
					size: e.data[0].file[r],
					br: a
				};
				break
			}
		}
		return l || (l = {
			url: "",
			size: 0,
			br: -1
		}), JSON.stringify(l)
	}
	decodeHtmlEntities(t) {
		if (!t) return t;
		const e = {
			"&apos;": "'",
			"&quot;": '"',
			"&amp;": "&",
			"&lt;": "<",
			"&gt;": ">",
			"&nbsp;": " "
		};
		let r = t;
		for (const [t, i] of Object.entries(e)) r = r.replace(new RegExp(t, "g"), i);
		return r = r.replace(/&#(\d+);/g, (t, e) => String.fromCharCode(parseInt(e, 10))), r = r.replace(/&#x([0-9a-fA-F]+);/g, (t, e) => String.fromCharCode(parseInt(e, 16))), r
	}
	lyricDecode(t) {
		const e = t.substring(18, t.length - 1),
			r = JSON.parse(e),
			i = {
				lyric: r.lyric ? this.decodeHtmlEntities(Buffer.from(r.lyric, "base64").toString()) : "",
				tlyric: r.trans ? this.decodeHtmlEntities(Buffer.from(r.trans, "base64").toString()) : ""
			};
		return JSON.stringify(i)
	}
}
class o extends r {
	constructor(t) {
		super(t), this.name = "kugou"
	}
	getHeaders() {
		return {
			"User-Agent": "IPhone-8990-searchSong",
			"UNI-UserAgent": "iOS11.4-Phone8990-1009-0-WiFi"
		}
	}
	search(t, e = {}) {
		return {
			method: "GET",
			url: "http://mobilecdn.kugou.com/api/v3/search/song",
			body: {
				api_ver: 1,
				area_code: 1,
				correct: 1,
				pagesize: e.limit || 30,
				plat: 2,
				tag: 1,
				sver: 5,
				showtype: 10,
				page: e.page || 1,
				keyword: t,
				version: 8990
			},
			format: "data.info"
		}
	}
	song(t) {
		return {
			method: "POST",
			url: "http://m.kugou.com/app/i/getSongInfo.php",
			body: {
				cmd: "playInfo",
				hash: t,
				from: "mkugou"
			},
			format: ""
		}
	}
	album(t) {
		return {
			method: "GET",
			url: "http://mobilecdn.kugou.com/api/v3/album/song",
			body: {
				albumid: t,
				area_code: 1,
				plat: 2,
				page: 1,
				pagesize: -1,
				version: 8990
			},
			format: "data.info"
		}
	}
	artist(t, e = 50) {
		return {
			method: "GET",
			url: "http://mobilecdn.kugou.com/api/v3/singer/song",
			body: {
				singerid: t,
				area_code: 1,
				page: 1,
				plat: 0,
				pagesize: e,
				version: 8990
			},
			format: "data.info"
		}
	}
	playlist(t) {
		return {
			method: "GET",
			url: "http://mobilecdn.kugou.com/api/v3/special/song",
			body: {
				specialid: t,
				area_code: 1,
				page: 1,
				plat: 2,
				pagesize: -1,
				version: 8990
			},
			format: "data.info"
		}
	}
	url(t, e = 320) {
		return {
			method: "POST",
			url: "http://media.store.kugou.com/v1/get_res_privilege",
			body: JSON.stringify({
				relate: 1,
				userid: "0",
				vip: 0,
				appid: 1e3,
				token: "",
				behavior: "download",
				area_code: "1",
				clientver: "8990",
				resource: [{
					id: 0,
					type: "audio",
					hash: t
				}]
			}),
			decode: "kugou_url"
		}
	}
	lyric(t) {
		return {
			method: "GET",
			url: "http://krcs.kugou.com/search",
			body: {
				keyword: "%20-%20",
				ver: 1,
				hash: t,
				client: "mobi",
				man: "yes"
			},
			decode: "kugou_lyric"
		}
	}
	async pic(t, e = 300) {
		const r = this.meting.isFormat,
			i = await this.meting.format(!1).song(t);
		this.meting.isFormat = r;
		let a = JSON.parse(i).imgUrl;
		return a = a.replace("{size}", "400"), JSON.stringify({
			url: a
		})
	}
	format(t) {
		const e = t.filename || t.fileName,
			r = {
				id: t.hash,
				name: e,
				artist: [],
				album: t.album_name || "",
				url_id: t.hash,
				pic_id: t.hash,
				lyric_id: t.hash,
				source: "kugou"
			},
			i = e.split(" - ");
		return i.length >= 2 && (r.artist = i[0].split("„ÄÅ"), r.name = i[1]), r
	}
	async handleDecode(t, e) {
		return "kugou_url" === t ? this.urlDecode(e) : "kugou_lyric" === t ? this.lyricDecode(e) : e
	}
	async urlDecode(t) {
		const r = JSON.parse(t);
		let i, a = 0;
		for (const t of r.data[0].relate_goods)
			if (t.info.bitrate <= this.meting.temp.br && t.info.bitrate > a) {
				const r = {
						method: "GET",
						url: "http://trackercdn.kugou.com/i/v2/",
						body: {
							hash: t.hash,
							key: e.createHash("md5").update(t.hash + "kgcloudv2").digest("hex"),
							pid: 3,
							behavior: "play",
							cmd: "25",
							version: 8990
						}
					},
					o = JSON.parse(await this.meting._exec(r));
				o.url && (a = o.bitRate / 1e3, i = {
					url: Array.isArray(o.url) ? o.url[0] : o.url,
					size: o.fileSize,
					br: o.bitRate / 1e3
				})
			} return i || (i = {
			url: "",
			size: 0,
			br: -1
		}), JSON.stringify(i)
	}
	async lyricDecode(t) {
		const e = JSON.parse(t);
		if (!e.candidates || 0 === e.candidates.length) return JSON.stringify({
			lyric: "",
			tlyric: ""
		});
		const r = {
				method: "GET",
				url: "http://lyrics.kugou.com/download",
				body: {
					charset: "utf8",
					accesskey: e.candidates[0].accesskey,
					id: e.candidates[0].id,
					client: "mobi",
					fmt: "lrc",
					ver: 1
				}
			},
			i = JSON.parse(await this.meting._exec(r)),
			a = {
				lyric: Buffer.from(i.content, "base64").toString(),
				tlyric: ""
			};
		return JSON.stringify(a)
	}
}
class s extends r {
	constructor(t) {
		super(t), this.name = "baidu"
	}
	getHeaders() {
		return {
			Cookie: `BAIDUID=${this._getRandomHex(32)}:FG=1`,
			"User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) baidu-music/1.2.1 Chrome/66.0.3359.181 Electron/3.0.5 Safari/537.36",
			Accept: "*/*",
			"Content-Type": "application/json;charset=UTF-8",
			"Accept-Language": "zh-CN"
		}
	}
	search(t, e = {}) {
		return {
			method: "GET",
			url: "http://musicapi.taihe.com/v1/restserver/ting",
			body: {
				from: "qianqianmini",
				method: "baidu.ting.search.merge",
				isNew: 1,
				platform: "darwin",
				page_no: e.page || 1,
				query: t,
				version: "11.2.1",
				page_size: e.limit || 30
			},
			format: "result.song_info.song_list"
		}
	}
	song(t) {
		return {
			method: "GET",
			url: "http://musicapi.taihe.com/v1/restserver/ting",
			body: {
				from: "qianqianmini",
				method: "baidu.ting.song.getInfos",
				songid: t,
				res: 1,
				platform: "darwin",
				version: "1.0.0"
			},
			encode: "baidu_AESCBC",
			format: "songinfo"
		}
	}
	album(t) {
		return {
			method: "GET",
			url: "http://musicapi.taihe.com/v1/restserver/ting",
			body: {
				from: "qianqianmini",
				method: "baidu.ting.album.getAlbumInfo",
				album_id: t,
				platform: "darwin",
				version: "11.2.1"
			},
			format: "songlist"
		}
	}
	artist(t, e = 50) {
		return {
			method: "GET",
			url: "http://musicapi.taihe.com/v1/restserver/ting",
			body: {
				from: "qianqianmini",
				method: "baidu.ting.artist.getSongList",
				artistid: t,
				limits: e,
				platform: "darwin",
				offset: 0,
				tinguid: 0,
				version: "11.2.1"
			},
			format: "songlist"
		}
	}
	playlist(t) {
		return {
			method: "GET",
			url: "http://musicapi.taihe.com/v1/restserver/ting",
			body: {
				from: "qianqianmini",
				method: "baidu.ting.diy.gedanInfo",
				listid: t,
				platform: "darwin",
				version: "11.2.1"
			},
			format: "content"
		}
	}
	url(t, e = 320) {
		return {
			method: "GET",
			url: "http://musicapi.taihe.com/v1/restserver/ting",
			body: {
				from: "qianqianmini",
				method: "baidu.ting.song.getInfos",
				songid: t,
				res: 1,
				platform: "darwin",
				version: "1.0.0"
			},
			encode: "baidu_AESCBC",
			decode: "baidu_url"
		}
	}
	lyric(t) {
		return {
			method: "GET",
			url: "http://musicapi.taihe.com/v1/restserver/ting",
			body: {
				from: "qianqianmini",
				method: "baidu.ting.song.lry",
				songid: t,
				platform: "darwin",
				version: "1.0.0"
			},
			decode: "baidu_lyric"
		}
	}
	async pic(t, e = 300) {
		const r = this.meting.isFormat,
			i = await this.meting.format(!1).song(t);
		this.meting.isFormat = r;
		const a = JSON.parse(i),
			o = a.songinfo.pic_radio || a.songinfo.pic_small;
		return JSON.stringify({
			url: o
		})
	}
	format(t) {
		return {
			id: t.song_id,
			name: t.title,
			artist: t.author ? t.author.split(",") : [],
			album: t.album_title || "",
			pic_id: t.song_id,
			url_id: t.song_id,
			lyric_id: t.song_id,
			source: "baidu"
		}
	}
	async handleEncode(t) {
		return "baidu_AESCBC" === t.encode ? this.aesEncrypt(t) : t
	}
	async handleDecode(t, e) {
		return "baidu_url" === t ? this.urlDecode(e) : "baidu_lyric" === t ? this.lyricDecode(e) : e
	}
	async aesEncrypt(t) {
		const r = `songid=${t.body.songid}&ts=${Date.now()}`,
			i = e.createCipheriv("aes-128-cbc", "DBEECF8C50FD160E", "1231021386755796");
		i.setAutoPadding(!0);
		let a = i.update(r, "utf8", "base64");
		return a += i.final("base64"), t.body.e = a, t
	}
	urlDecode(t) {
		const e = JSON.parse(t);
		let r, i = 0;
		return e.songurl.url.forEach(t => {
			t.file_bitrate <= this.meting.temp.br && t.file_bitrate > i && (i = t.file_bitrate, r = {
				url: t.file_link,
				br: t.file_bitrate
			})
		}), r || (r = {
			url: "",
			br: -1
		}), JSON.stringify(r)
	}
	lyricDecode(t) {
		const e = {
			lyric: JSON.parse(t).lrcContent || "",
			tlyric: ""
		};
		return JSON.stringify(e)
	}
	_getRandomHex(t) {
		return e.randomBytes(Math.ceil(t / 2)).toString("hex").slice(0, t)
	}
}
class n extends r {
	constructor(t) {
		super(t), this.name = "kuwo"
	}
	getHeaders() {
		return {
			Cookie: "Hm_lvt_cdb524f42f0ce19b169a8071123a4797=1623339177,1623339183; _ga=GA1.2.1195980605.1579367081; Hm_lpvt_cdb524f42f0ce19b169a8071123a4797=1623339982; kw_token=3E7JFQ7MRPL; _gid=GA1.2.747985028.1623339179; _gat=1",
			csrf: "3E7JFQ7MRPL",
			Host: "www.kuwo.cn",
			Referer: "http://www.kuwo.cn/",
			"User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.77 Safari/537.36"
		}
	}
	search(t, e = {}) {
		return {
			method: "GET",
			url: "http://www.kuwo.cn/api/www/search/searchMusicBykeyWord",
			body: {
				key: t,
				pn: e.page || 1,
				rn: e.limit || 30,
				httpsStatus: 1
			},
			format: "data.list"
		}
	}
	song(t) {
		return {
			method: "GET",
			url: "http://www.kuwo.cn/api/www/music/musicInfo",
			body: {
				mid: t,
				httpsStatus: 1
			},
			format: "data"
		}
	}
	album(t) {
		return {
			method: "GET",
			url: "http://www.kuwo.cn/api/www/album/albumInfo",
			body: {
				albumId: t,
				pn: 1,
				rn: 1e3,
				httpsStatus: 1
			},
			format: "data.musicList"
		}
	}
	artist(t, e = 50) {
		return {
			method: "GET",
			url: "http://www.kuwo.cn/api/www/artist/artistMusic",
			body: {
				artistid: t,
				pn: 1,
				rn: e,
				httpsStatus: 1
			},
			format: "data.list"
		}
	}
	playlist(t) {
		return {
			method: "GET",
			url: "http://www.kuwo.cn/api/www/playlist/playListInfo",
			body: {
				pid: t,
				pn: 1,
				rn: 1e3,
				httpsStatus: 1
			},
			format: "data.musicList"
		}
	}
	url(t, e = 320) {
		return {
			method: "GET",
			url: "http://www.kuwo.cn/api/v1/www/music/playUrl",
			body: {
				mid: t,
				type: "music",
				httpsStatus: 1
			},
			decode: "kuwo_url"
		}
	}
	lyric(t) {
		return {
			method: "GET",
			url: "http://m.kuwo.cn/newh5/singles/songinfoandlrc",
			body: {
				musicId: t,
				httpsStatus: 1
			},
			decode: "kuwo_lyric"
		}
	}
	async pic(t, e = 300) {
		const r = this.meting.isFormat,
			i = await this.meting.format(!1).song(t);
		this.meting.isFormat = r;
		const a = JSON.parse(i),
			o = a.data.pic || a.data.albumpic;
		return JSON.stringify({
			url: o
		})
	}
	format(t) {
		return {
			id: t.rid,
			name: t.name,
			artist: t.artist ? t.artist.split("&") : [],
			album: t.album || "",
			pic_id: t.rid,
			url_id: t.rid,
			lyric_id: t.rid,
			source: "kuwo"
		}
	}
	async handleDecode(t, e) {
		return "kuwo_url" === t ? this.urlDecode(e) : "kuwo_lyric" === t ? this.lyricDecode(e) : e
	}
	urlDecode(t) {
		const e = JSON.parse(t);
		let r;
		return r = 200 === e.code && e.data && e.data.url ? {
			url: e.data.url,
			br: 128
		} : {
			url: "",
			br: -1
		}, JSON.stringify(r)
	}
	lyricDecode(t) {
		const e = JSON.parse(t);
		let r = "";
		e.data && e.data.lrclist && e.data.lrclist.length > 0 && e.data.lrclist.forEach(t => {
			const e = parseFloat(t.time),
				i = Math.floor(e / 60).toString().padStart(2, "0"),
				a = Math.floor(e % 60).toString().padStart(2, "0"),
				o = (e % 1 * 100).toFixed(0).padStart(2, "0");
			r += `[${i}:${a}.${o}]${t.lineLyric}\n`
		});
		const i = {
			lyric: r,
			tlyric: ""
		};
		return JSON.stringify(i)
	}
}
class c {
	static providers = {
		netease: i,
		tencent: a,
		kugou: o,
		baidu: s,
		kuwo: n
	};
	static create(t, e) {
		const r = this.providers[t];
		if (!r) throw new Error(`Unsupported platform: ${t}`);
		return new r(e)
	}
	static getSupportedPlatforms() {
		return Object.keys(this.providers)
	}
	static isSupported(t) {
		return t in this.providers
	}
}
class d {
	constructor(t = "netease") {
		this.VERSION = "1.6.0", this.raw = null, this.info = null, this.error = null, this.status = null, this.temp = {}, this.server = null, this.provider = null, this.isFormat = !1, this.header = {}, this.site(t)
	}
	site(t) {
		return c.isSupported(t) || (t = "netease"), this.server = t, this.provider = c.create(t, this), this.header = this.provider.getHeaders(), this
	}
	cookie(t) {
		return this.header.Cookie = t, this
	}
	format(t = !0) {
		return this.isFormat = t, this
	}
	async _exec(t) {
		return await this.provider.executeRequest(t, this)
	}
	async _curl(e, r = null, i = !1) {
		const a = {
			method: r ? "POST" : "GET",
			headers: {
				...this.header
			}
		};
		r && ("object" != typeof r || Buffer.isBuffer(r) || "string" == typeof r || (r = new t(r).toString(), a.headers["Content-Type"] = "application/x-www-form-urlencoded"), a.body = r);
		const o = new AbortController,
			s = setTimeout(() => o.abort(), 2e4);
		a.signal = o.signal;
		let n = 3;
		const c = async () => {
			try {
				const t = await fetch(e, a);
				clearTimeout(s), this.info = {
					statusCode: t.status,
					headers: Object.fromEntries(t.headers.entries())
				};
				const r = await t.text();
				return this.raw = r, this.error = null, this.status = "", this
			} catch (t) {
				return clearTimeout(s), "AbortError" === t.name ? (this.error = "TIMEOUT", this.status = "Request timeout") : (this.error = t.code || t.name, this.status = t.message), n > 0 ? (n--, await new Promise(t => setTimeout(t, 1e3)), c()) : this
			}
		};
		return await c()
	}
	async search(t, e = {}) {
		const r = this.provider.search(t, e);
		return await this._exec(r)
	}
	async song(t) {
		const e = this.provider.song(t);
		return await this._exec(e)
	}
	async album(t) {
		const e = this.provider.album(t);
		return await this._exec(e)
	}
	async artist(t, e = 50) {
		const r = this.provider.artist(t, e);
		return await this._exec(r)
	}
	async playlist(t) {
		const e = this.provider.playlist(t);
		return await this._exec(e)
	}
	async url(t, e = 320) {
		this.temp.br = e;
		const r = this.provider.url(t, e);
		return await this._exec(r)
	}
	async lyric(t) {
		const e = this.provider.lyric(t);
		return await this._exec(e)
	}
	async pic(t, e = 300) {
		return await this.provider.pic(t, e)
	}
	static getSupportedPlatforms() {
		return c.getSupportedPlatforms()
	}
	static isSupported(t) {
		return c.isSupported(t)
	}
}
export {
	d as
	default
};